<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="实习的这两个多月基于Kafka开发系统，主要学习参考了Kafka权威指南这本书籍。正好也是第一次看原版的技术书籍，针对最重要的几个章节记录一下笔记。 Chapter 3 Kafka ProducersOverview通过创建一个ProducerRecord向Kafka发布消息，必须包括topic和value，可选指明key和/或者partition。  发布者会先序列化key和value对象成By">
<meta name="keywords">
<meta property="og:type" content="article">
<meta property="og:title" content="Kafka权威指南 笔记">
<meta property="og:url" content="http://yoursite.com/2018/03/18/Kafka权威指南-笔记/index.html">
<meta property="og:site_name" content="Silent Majority">
<meta property="og:description" content="实习的这两个多月基于Kafka开发系统，主要学习参考了Kafka权威指南这本书籍。正好也是第一次看原版的技术书籍，针对最重要的几个章节记录一下笔记。 Chapter 3 Kafka ProducersOverview通过创建一个ProducerRecord向Kafka发布消息，必须包括topic和value，可选指明key和/或者partition。  发布者会先序列化key和value对象成By">
<meta property="og:updated_time" content="2018-04-10T14:59:17.885Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kafka权威指南 笔记">
<meta name="twitter:description" content="实习的这两个多月基于Kafka开发系统，主要学习参考了Kafka权威指南这本书籍。正好也是第一次看原版的技术书籍，针对最重要的几个章节记录一下笔记。 Chapter 3 Kafka ProducersOverview通过创建一个ProducerRecord向Kafka发布消息，必须包括topic和value，可选指明key和/或者partition。  发布者会先序列化key和value对象成By">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/03/18/Kafka权威指南-笔记/"/>





  <title> Kafka权威指南 笔记 | Silent Majority </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Silent Majority</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/18/Kafka权威指南-笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Edward">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Silent Majority">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Kafka权威指南 笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-18T21:41:46+08:00">
                2018-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>实习的这两个多月基于Kafka开发系统，主要学习参考了Kafka权威指南这本书籍。正好也是第一次看原版的技术书籍，针对最重要的几个章节记录一下笔记。</p>
<h1 id="Chapter-3-Kafka-Producers"><a href="#Chapter-3-Kafka-Producers" class="headerlink" title="Chapter 3 Kafka Producers"></a>Chapter 3 Kafka Producers</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>通过创建一个<code>ProducerRecord</code>向Kafka发布消息，必须包括topic和value，可选指明key和/或者partition。</p>
<ol>
<li>发布者会先序列化key和value对象成<code>ByteArrays</code>以便在网络上传递。</li>
<li>数据被传递给partitioner。如果指定了partition，partitioner不会有任何操作并返回指定的partition。如果没有指定，partition会基于key选择一个partition。一旦选择了partition后，producer将会知道record发往的topic和partition，然后将在一批发往同一topic和partition的records中加入record。一个独立的线程负责把这些成批的records发往合适的Kafka集群。</li>
<li>集群收到消息，将会返回一个响应。如果消息成功写入Kafka，它会返回一个包含topic，partition和offset的<code>RecordMetadata</code>对象。如果消息写入失败，它会返回一个error。当producer收到一个error，它可能会在放弃返回error前重试几次发送消息。</li>
</ol>
<h2 id="Constructing-a-Kafka-Producer"><a href="#Constructing-a-Kafka-Producer" class="headerlink" title="Constructing a Kafka Producer"></a>Constructing a Kafka Producer</h2><ul>
<li>bootstrap.servers</li>
<li>key.serializer</li>
<li>value.serializer</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Properties kafkaProps = <span class="keyword">new</span> Properties();</div><div class="line">kafkaProps.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"broker1:9092,broker2:9092"</span>);</div><div class="line">kafkaProps.put(<span class="string">"key.serializer"</span>,<span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</div><div class="line">kafkaProps.put(<span class="string">"value.serializer"</span>,<span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</div><div class="line">producer = <span class="keyword">new</span> KafkaProducer&lt;String, String&gt;(kafkaProps);</div></pre></td></tr></table></figure>
<p>创建了producer后，开始发送消息。主要有三种发送消息的方法</p>
<ul>
<li><p>Fire-and-forget</p>
<p>发送消息到服务器并不在意是否成功到达，一些消息可能丢失</p>
</li>
<li><p>Synchronous send</p>
<p><code>send()</code>方法返回一个<code>Future</code>对象，使用<code>get()</code>方法等待future查看send是否成功</p>
</li>
<li><p>Asynchronous send</p>
<p>与<code>send()</code>一起使用callback函数，当收到Kafka集群响应后被出发</p>
</li>
</ul>
<h2 id="Sending-a-Message-to-Kafka"><a href="#Sending-a-Message-to-Kafka" class="headerlink" title="Sending a Message to Kafka"></a>Sending a Message to Kafka</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"CustomerCountry"</span>, <span class="string">"Precision Products"</span>, <span class="string">"France"</span>);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  producer.send(record);</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">  e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Sending-a-Message-Synchronously"><a href="#Sending-a-Message-Synchronously" class="headerlink" title="Sending a Message Synchronously"></a>Sending a Message Synchronously</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"CustomerCountry"</span>, <span class="string">"Precision Products"</span>, <span class="string">"France"</span>);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  producer.send(record).get();</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">  e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Sending-a-Message-Asynchronously"><a href="#Sending-a-Message-Asynchronously" class="headerlink" title="Sending a Message Asynchronously"></a>Sending a Message Asynchronously</h2><p>同步发送消息可能导致延迟，同时我们需要知道是否成功</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoProducerCallback</span> <span class="keyword">implements</span> <span class="title">Callback</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata recordMetadata, Exception e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"CustomerCountry"</span>, <span class="string">"Biomedical Materials"</span>, <span class="string">"USA"</span>);</div><div class="line">producer.send(record, <span class="keyword">new</span> DemoProducerCallback());</div></pre></td></tr></table></figure>
<h2 id="Configuring-Producers"><a href="#Configuring-Producers" class="headerlink" title="Configuring Producers"></a>Configuring Producers</h2><ul>
<li><p>acks</p>
<ul>
<li>ack=0：producer不会等待broker的响应，高吞吐率但不能得知消息是否丢失</li>
<li>ack=1：producer在leader replica收到消息时得到来自broker的成功响应。如果消息不能被写入leader，producer会收到error响应并重试发送消息避免消息丢失。</li>
<li>ack=all：producer在所有in-sync replica收到消息时得到来自broker的成功响应，延迟高</li>
</ul>
</li>
<li><p>buffer.memory</p>
<p>设置producer用于缓存等待发往broker消息的缓存大小</p>
</li>
<li><p>compression.type</p>
<p>默认消息未被压缩发送</p>
</li>
<li><p>retries</p>
<p>放弃并通知问题前重试发送消息的次数</p>
</li>
<li><p>batch.size</p>
<p>当多个records被发往同一partition，producer将会分批发送。控制用于每一批消息内存大小的bytes数量。批次满时，批次内消息会被发送，但这未必意味着producer会等待批次满再发送。</p>
</li>
<li><p>linger.ms</p>
<p>发送当前批次消息前等待额外消息的时间。<code>KafkaProducer</code>在当前批次消息满或者到达<code>linger.ms</code>限制时发送一批消息。默认在一有可用发送消息线程时就发送消息。</p>
</li>
<li><p>max.request.size</p>
<p>producer发送请求的大小——最大可发送消息的大小和一次请求中可以发送消息的数量</p>
</li>
</ul>
<h2 id="Partitions"><a href="#Partitions" class="headerlink" title="Partitions"></a>Partitions</h2><p>只使用topic和value创建<code>ProducerRecord</code>时，key被默认设置未null。Key有两个作用：与消息一起存储的额外信息并用于决定信息被写往的topic partition。所有相同key的消息将到相同的partition中，意味着如果一个进程只读取topic partitions的一个子集时，所有单个key的记录将被同个进程读取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ProducerRecord&lt;Integer, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"CustomerCountry"</span>, <span class="string">"Laboratory Equipment"</span>, <span class="string">"USA"</span>);</div></pre></td></tr></table></figure>
<p>当key为null，将会使用默认的partitioner，记录会被随机发送可用的partition之一。轮询算法被用于partitions之间消息的平衡。当key存在且默认的partitioner被使用时，Kafka使用自己的hash算法对key进行hash，使用结果映射消息到特定的partition。因为一个key总是映射到同一partition，使用topic中所有partition计算映射，而不是可用的partitions。只有当topic的partition数量不变时，keys到partitions的映射是不变的。当topic中加入新的partition，新的记录会被写往不同的partition中。</p>
<h1 id="Chapter-4-Kafka-Consumers"><a href="#Chapter-4-Kafka-Consumers" class="headerlink" title="Chapter 4 Kafka Consumers"></a>Chapter 4 Kafka Consumers</h1><h2 id="Kafka-Consumer-Concepts"><a href="#Kafka-Consumer-Concepts" class="headerlink" title="Kafka Consumer Concepts"></a>Kafka Consumer Concepts</h2><h3 id="Consumers-and-Consumer-Groups"><a href="#Consumers-and-Consumer-Groups" class="headerlink" title="Consumers and Consumer Groups"></a>Consumers and Consumer Groups</h3><p>Kafka consumers是consumer group的一部分。当同一consumer group中的多个consumers订阅了一个topic时，组内的每一个consumer将会收到topic不同partition子集的消息。</p>
<ul>
<li><p>Partition Num &gt; Consumer Num (1)</p>
<p>consumer会收到所有partition的消息</p>
</li>
<li><p>Partition Num &gt; Consumer Num (&gt; 1)</p>
<p>每一个consumer收到不同的partition子集的消息</p>
</li>
<li><p>Partition Num = Consumer Num</p>
<p>每一个consumer收到一个parition的消息</p>
</li>
<li><p>Partition Num &lt; Consumer Num</p>
<p>部分consume收不到消息</p>
</li>
<li><p>consumer group num &gt; 1</p>
<p>每一个组会单独收到partition所有的消息，组内负载均衡</p>
</li>
</ul>
<h3 id="Consumer-Groups-and-Partition-Rebalance"><a href="#Consumer-Groups-and-Partition-Rebalance" class="headerlink" title="Consumer Groups and Partition Rebalance"></a>Consumer Groups and Partition Rebalance</h3><p>组内添加一个新的consumer或者一个consumer关闭或者崩溃时，会开始消费其他consumer之前消费的partition。从一个consumer移动partition的归属到另一个consumer叫做再平衡。再平衡时整个consumer group会暂时不可用。Consumer通过发送心跳到Kafka称为group coordinator的broker保持在一个consumer group的成员归属以及partition的归属。只要consumer以规律的时间间隔发送心跳，它就被认为是存活的并从partition处理消息。Consumer poll时发送消息，已经消费了就commit record。一旦consumer足够长时间内停止发送心跳，session就会超时，group coordinator就会认为它死亡并出发再平衡。新版本中有独立的心跳线程再poll之间发送心跳，允许分离心跳频率和poll的频率。</p>
<h2 id="Creating-a-Kafka-Consumer"><a href="#Creating-a-Kafka-Consumer" class="headerlink" title="Creating a Kafka Consumer"></a>Creating a Kafka Consumer</h2><ul>
<li>bootstrap.servers</li>
<li>key.deserializer</li>
<li>value.deserializer</li>
<li>group.id 非必需</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Properties props = <span class="keyword">new</span> Properties();</div><div class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"broker1:9092,broker2:9092"</span>);</div><div class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"CountryCounter"</span>);</div><div class="line">props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</div><div class="line">props.put(<span class="string">"value.deserializer"</span>,<span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</div><div class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;String, String&gt;(props);</div></pre></td></tr></table></figure>
<h2 id="Subscribing-to-Topics"><a href="#Subscribing-to-Topics" class="headerlink" title="Subscribing to Topics"></a>Subscribing to Topics</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">consumer.subscribe(Collections.singletonList(<span class="string">"customerCountries"</span>));</div><div class="line">consumer.subscribe(<span class="string">"test.*"</span>);</div></pre></td></tr></table></figure>
<h2 id="The-Poll-Loop"><a href="#The-Poll-Loop" class="headerlink" title="The Poll Loop"></a>The Poll Loop</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">            log.debug(<span class="string">"topic = %s, partition = %s, offset = %d,customer = %s, country = %s\n"</span>,</div><div class="line">                      record.topic(), record.partition(), record.offset(), record.key(), 						record.value());</div><div class="line"> 			<span class="keyword">int</span> updatedCount = <span class="number">1</span>;</div><div class="line"> 			<span class="keyword">if</span> (custCountryMap.countainsValue(record.value())) &#123;</div><div class="line"> 				updatedCount = custCountryMap.get(record.value()) + <span class="number">1</span>;</div><div class="line"> 			&#125;</div><div class="line"> 			custCountryMap.put(record.value(), updatedCount)</div><div class="line"> 			JSONObject json = <span class="keyword">new</span> JSONObject(custCountryMap);</div><div class="line"> 			System.out.println(json.toString(<span class="number">4</span>))</div><div class="line"> 		&#125;</div><div class="line"> 	&#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    consumer.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一次使用新的consumer调用<code>poll()</code>时，负责找到<code>GroupCoordinator</code>，加入consumer group，收到partition的分配。</p>
<h3 id="Thread-safe"><a href="#Thread-safe" class="headerlink" title="Thread safe"></a>Thread safe</h3><p>One consumer per thread is the rule.</p>
<h2 id="Configuring-Consumers"><a href="#Configuring-Consumers" class="headerlink" title="Configuring Consumers"></a>Configuring Consumers</h2><ul>
<li><p>fetch.min.bytes</p>
<p>获取records时希望从broker获取的数据的最小量。如果新的records比min.fetch.bytes的byte数少时，broker会再发送records返回给consumer前等待更多可用的信息</p>
</li>
<li><p>fetch.max.wait.ms</p>
<p>默认Kafka等待500ms。</p>
</li>
<li><p>max.partition.fetch.bytes</p>
<p>服务器每个partition返回的最大bytes数量</p>
</li>
<li><p>session.timeout.ms</p>
</li>
<li><p>auto.offset.reset</p>
</li>
<li><p>enable.auto.commit</p>
</li>
<li><p>partition.assignment.strategy 随机/轮询</p>
</li>
<li><p>max.poll.records</p>
<p>单次调用poll<code>()</code>返回的最大records数量</p>
</li>
<li><p>receive.buffer.bytes and send.buffer.bytes</p>
</li>
</ul>
<h2 id="Commits-and-Offsets"><a href="#Commits-and-Offsets" class="headerlink" title="Commits and Offsets"></a>Commits and Offsets</h2><p>我们称一个partition中更新当前位置的动作为commit。消费者生产一条带着每个partition的committed offset消息至Kafka<code>__consumer_offsets</code>的topic。如果一个消费者崩溃或者新的消费者加入了消费者组，将会触发rebalance。rebalance后，每个消费者可能被分配到新的一组partition，为了知道从哪里开始工作，消费者会从那里读取最新的每个parition的committed offset。</p>
<p>如果committed offset比起消费者处理的最后一条消息offset小，committed offset和最后处理的offset间的消息会被处理两次；</p>
<p>如果committed offset比起消费者实际处理的最后一条消息offset大，committed offset和最后处理的offset间的消息会被消费者组丢失。</p>
<h3 id="Automatic-Commit"><a href="#Automatic-Commit" class="headerlink" title="Automatic Commit"></a>Automatic Commit</h3><p>如果配置了<code>enable.auto.commit=true</code>，每5秒钟消费者将会commit从<code>poll()</code>中收到的最大的offset。5秒钟的间隔是默认值并由<code>auto.commit.interval.ms</code>设置。自动commit由poll循环驱动。无论何时poll时，消费者检查是否是时间commit，如果是则commit上一次poll时返回的offset。</p>
<p>可以通过配置commit间隔使得更加频繁地commit并减少records重复的窗口，但不可能消除。通过使能自动commit，一次poll的调用总是返回上一次poll的最后一个offset，所以再次调用poll之前处理poll返回的所有event十分重要。</p>
<h3 id="Commit-Current-Offset"><a href="#Commit-Current-Offset" class="headerlink" title="Commit Current Offset"></a>Commit Current Offset</h3><p>设置<code>auto.commit.offset=false</code>，offsets只有在应用显式commit时才会被commit。最简单可靠的API是<code>commitSync()</code>，这个API会<strong>commit由<code>poll()</code>返回的最新的offset</strong>，一旦offset被commit就返回，如果commit由于某些原因失败了就抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line"> 		System.out.printf(<span class="string">"topic = %s, partition = %s, offset = %d, customer = %s, country = %s\n"</span>, record.topic(), record.partition(), record.offset(), record.key(), record.value());</div><div class="line">    &#125;</div><div class="line"> 	<span class="keyword">try</span> &#123;</div><div class="line"> 		consumer.commitSync();</div><div class="line"> 	&#125; <span class="keyword">catch</span> (CommitFailedException e) &#123;</div><div class="line"> 		log.error(<span class="string">"commit failed"</span>, e)</div><div class="line"> 	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一旦处理完当前批次的records，在poll更多消息前调用<code>commitSync()</code>commit批次中最后一个offset。</p>
<h3 id="Asynchronous-Commit"><a href="#Asynchronous-Commit" class="headerlink" title="Asynchronous Commit"></a>Asynchronous Commit</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">        System.out.printf(<span class="string">"topic = %s, partition = %s, offset = %d, customer = %s, country = %s\n"</span>, record.topic(), record.partition(), record.offset(), record.key(), record.value());</div><div class="line">    &#125;</div><div class="line"> 	consumer.commitAsync();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>commitAsync()</code>将会重试commit直到要么成功要么遇到不可重试的失败。原因是<code>commitAsync()</code>收到来自服务器的响应时，可能有更晚一些的commit已经成功。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">        System.out.printf(<span class="string">"topic = %s, partition = %s, offset = %d, customer = %s, country = %s\n"</span>, record.topic(), record.partition(), record.offset(), record.key(), record.value());</div><div class="line">    &#125;</div><div class="line"> 	consumer.commitAsync(<span class="keyword">new</span> OffsetCommitCallback() &#123;</div><div class="line"> 		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(Map&lt;TopicPartition,OffsetAndMetadata&gt; offsets, Exception exception)</span> </span>&#123;</div><div class="line"> 			<span class="keyword">if</span> (e != <span class="keyword">null</span>)</div><div class="line"> 				log.error(<span class="string">"Commit failed for offsets &#123;&#125;"</span>, offsets, e);</div><div class="line"> 			&#125;</div><div class="line"> 	&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>保证异步重试commit顺序正确的简单策略时使用递增序列数字。每次commit时增加序列号。当准备发送重试消息时，检查commit序列号是否等于实例变量。如果相等，没有更新的commit，重试是安全的。如果实例序列号更大则不要重试，因为更新的commit已经被发送。</p>
<h3 id="Combining-Synchronous-and-Asynchronous-Commits"><a href="#Combining-Synchronous-and-Asynchronous-Commits" class="headerlink" title="Combining Synchronous and Asynchronous Commits"></a>Combining Synchronous and Asynchronous Commits</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">            System.out.printf(<span class="string">"topic = %s, partition = %s, offset = %d, customer = %s, country = %s\n"</span>, record.topic(), record.partition(), record.offset(), record.key(), record.value());</div><div class="line">        &#125;</div><div class="line"> 		consumer.commitAsync();</div><div class="line"> 	&#125;</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"> 	log.error(<span class="string">"Unexpected error"</span>, e);</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line"> 	<span class="keyword">try</span> &#123;</div><div class="line"> 		consumer.commitSync();</div><div class="line"> 	&#125; <span class="keyword">finally</span> &#123;</div><div class="line"> 		consumer.close();</div><div class="line"> 	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Commit-Specified-Offset"><a href="#Commit-Specified-Offset" class="headerlink" title="Commit Specified Offset"></a>Commit Specified Offset</h3><p>消费者API允许通过传递partition和希望commit的offset的映射调用<code>commitSync()</code>和<code>commitAsync()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; currentOffsets = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">....</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line"> 		System.out.printf(<span class="string">"topic = %s, partition = %s, offset = %d, customer = %s, country = %s\n"</span>, record.topic(), record.partition(), record.offset(), record.key(), record.value());</div><div class="line"> 		currentOffsets.put(<span class="keyword">new</span> TopicPartition(record.topic(), record.partition()), <span class="keyword">new</span></div><div class="line"> OffsetAndMetadata(record.offset()+<span class="number">1</span>, <span class="string">"no metadata"</span>));</div><div class="line"> 		<span class="keyword">if</span> (count % <span class="number">1000</span> == <span class="number">0</span>) consumer.commitAsync(currentOffsets, <span class="keyword">null</span>);</div><div class="line"> 		count++;</div><div class="line"> 	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>读取每个record后，通过我们希望处理的下一个offset更新offset的映射，这是下次开始时开始读取的地方。</p>
<h3 id="Consuming-Records-with-Specific-Offsets"><a href="#Consuming-Records-with-Specific-Offsets" class="headerlink" title="Consuming Records with Specific Offsets"></a>Consuming Records with Specific Offsets</h3><p>如果想从partition的开始开始读取所有消息或者跳过所有消息到partition的尾开始只消费新的消息，使用<code>seekToBeginning(TopicPartition tp)</code>和<code>seekToEnd(TopicPartition tp)</code>。</p>
<p>或者使用<code>seek()</code>指定哪里开始读取。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/11/操作系统面试相关问题汇总/" rel="next" title="操作系统面试相关问题汇总">
                <i class="fa fa-chevron-left"></i> 操作系统面试相关问题汇总
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/10/08/实战Java虚拟机-JVM故障诊断与性能优化-笔记/" rel="prev" title="实战Java虚拟机 JVM故障诊断与性能优化 笔记">
                实战Java虚拟机 JVM故障诊断与性能优化 笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Edward" />
          <p class="site-author-name" itemprop="name">Edward</p>
           
              <p class="site-description motion-element" itemprop="description">SE @ SJTU</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-3-Kafka-Producers"><span class="nav-number">1.</span> <span class="nav-text">Chapter 3 Kafka Producers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Overview"><span class="nav-number">1.1.</span> <span class="nav-text">Overview</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Constructing-a-Kafka-Producer"><span class="nav-number">1.2.</span> <span class="nav-text">Constructing a Kafka Producer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sending-a-Message-to-Kafka"><span class="nav-number">1.3.</span> <span class="nav-text">Sending a Message to Kafka</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sending-a-Message-Synchronously"><span class="nav-number">1.4.</span> <span class="nav-text">Sending a Message Synchronously</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sending-a-Message-Asynchronously"><span class="nav-number">1.5.</span> <span class="nav-text">Sending a Message Asynchronously</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Configuring-Producers"><span class="nav-number">1.6.</span> <span class="nav-text">Configuring Producers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Partitions"><span class="nav-number">1.7.</span> <span class="nav-text">Partitions</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-4-Kafka-Consumers"><span class="nav-number">2.</span> <span class="nav-text">Chapter 4 Kafka Consumers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka-Consumer-Concepts"><span class="nav-number">2.1.</span> <span class="nav-text">Kafka Consumer Concepts</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Consumers-and-Consumer-Groups"><span class="nav-number">2.1.1.</span> <span class="nav-text">Consumers and Consumer Groups</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Consumer-Groups-and-Partition-Rebalance"><span class="nav-number">2.1.2.</span> <span class="nav-text">Consumer Groups and Partition Rebalance</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Creating-a-Kafka-Consumer"><span class="nav-number">2.2.</span> <span class="nav-text">Creating a Kafka Consumer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Subscribing-to-Topics"><span class="nav-number">2.3.</span> <span class="nav-text">Subscribing to Topics</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Poll-Loop"><span class="nav-number">2.4.</span> <span class="nav-text">The Poll Loop</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-safe"><span class="nav-number">2.4.1.</span> <span class="nav-text">Thread safe</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Configuring-Consumers"><span class="nav-number">2.5.</span> <span class="nav-text">Configuring Consumers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Commits-and-Offsets"><span class="nav-number">2.6.</span> <span class="nav-text">Commits and Offsets</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Automatic-Commit"><span class="nav-number">2.6.1.</span> <span class="nav-text">Automatic Commit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Commit-Current-Offset"><span class="nav-number">2.6.2.</span> <span class="nav-text">Commit Current Offset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Asynchronous-Commit"><span class="nav-number">2.6.3.</span> <span class="nav-text">Asynchronous Commit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Combining-Synchronous-and-Asynchronous-Commits"><span class="nav-number">2.6.4.</span> <span class="nav-text">Combining Synchronous and Asynchronous Commits</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Commit-Specified-Offset"><span class="nav-number">2.6.5.</span> <span class="nav-text">Commit Specified Offset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Consuming-Records-with-Specific-Offsets"><span class="nav-number">2.6.6.</span> <span class="nav-text">Consuming Records with Specific Offsets</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Edward</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  








  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
